#!/usr/bin/env python3
"""
Exploiting the discovered property: DAMPENING

The interference encoding MUTES small changes (0.04x amplification).
Can we use this for something actually novel?

Hypothesis: If small changes are dampened, this could serve as a
"fuzzy structural hash" - similar structures produce similar hashes
even with minor variations.

This would be novel if:
- It outperforms simple structural comparison
- It reveals "structural similarity" in a way that's computationally cheaper
- It has properties that existing fuzzy hashing doesn't have
"""

import numpy as np
from temporal_interference_codec import InterferenceCodec
import time


def compute_structural_distance(data1, data2, codec):
    """Compute distance using interference signatures"""
    sig1 = codec.encode(data1, duration=0.1)  # Shorter for speed
    sig2 = codec.encode(data2, duration=0.1)

    sig1_norm = sig1 / np.linalg.norm(sig1)
    sig2_norm = sig2 / np.linalg.norm(sig2)

    # Distance from correlation
    return 1 - np.dot(sig1_norm, sig2_norm)


def naive_structural_distance(data1, data2):
    """Naive comparison: just compare JSON representations"""
    s1 = str(data1)
    s2 = str(data2)

    # Levenshtein-like but simpler: character difference ratio
    max_len = max(len(s1), len(s2))
    if max_len == 0:
        return 0

    # Count differences
    diffs = sum(1 for a, b in zip(s1, s2) if a != b)
    diffs += abs(len(s1) - len(s2))

    return diffs / max_len


def test_fuzzy_matching():
    """
    Can interference encoding do fuzzy structural matching better than naive?
    """
    codec = InterferenceCodec()

    # Base structure
    base = {
        "users": [
            {"name": "Alice", "age": 30, "scores": [85, 90, 88]},
            {"name": "Bob", "age": 25, "scores": [92, 88, 91]}
        ]
    }

    # Various mutations
    mutations = {
        "Age change": {
            "users": [
                {"name": "Alice", "age": 31, "scores": [85, 90, 88]},  # 30->31
                {"name": "Bob", "age": 25, "scores": [92, 88, 91]}
            ]
        },
        "Score change": {
            "users": [
                {"name": "Alice", "age": 30, "scores": [86, 90, 88]},  # 85->86
                {"name": "Bob", "age": 25, "scores": [92, 88, 91]}
            ]
        },
        "Name change": {
            "users": [
                {"name": "Alicia", "age": 30, "scores": [85, 90, 88]},  # Alice->Alicia
                {"name": "Bob", "age": 25, "scores": [92, 88, 91]}
            ]
        },
        "Add user": {
            "users": [
                {"name": "Alice", "age": 30, "scores": [85, 90, 88]},
                {"name": "Bob", "age": 25, "scores": [92, 88, 91]},
                {"name": "Charlie", "age": 35, "scores": [88, 89, 90]}
            ]
        },
        "Reorder": {
            "users": [
                {"name": "Bob", "age": 25, "scores": [92, 88, 91]},
                {"name": "Alice", "age": 30, "scores": [85, 90, 88]}
            ]
        },
        "Different structure": {
            "count": 2,
            "data": ["Alice:30", "Bob:25"]
        }
    }

    print("FUZZY STRUCTURAL MATCHING TEST")
    print("=" * 60)
    print("\nBase structure:")
    print(base)
    print("\nComparing various mutations...\n")

    results = []

    for name, mutated in mutations.items():
        # Time interference method
        start = time.time()
        interference_dist = compute_structural_distance(base, mutated, codec)
        interference_time = time.time() - start

        # Time naive method
        start = time.time()
        naive_dist = naive_structural_distance(base, mutated)
        naive_time = time.time() - start

        results.append({
            'name': name,
            'interference_dist': interference_dist,
            'naive_dist': naive_dist,
            'interference_time': interference_time,
            'naive_time': naive_time
        })

        print(f"{name:20} | Interference: {interference_dist:.4f} ({interference_time*1000:.2f}ms) "
              f"| Naive: {naive_dist:.4f} ({naive_time*1000:.2f}ms)")

    # Analysis
    print("\n" + "=" * 60)
    print("ANALYSIS")
    print("=" * 60)

    # Rank by interference distance
    sorted_interference = sorted(results, key=lambda x: x['interference_dist'])
    print("\nRanking by Interference distance (closest to base first):")
    for i, r in enumerate(sorted_interference, 1):
        print(f"  {i}. {r['name']:20} ({r['interference_dist']:.4f})")

    # Rank by naive distance
    sorted_naive = sorted(results, key=lambda x: x['naive_dist'])
    print("\nRanking by Naive distance (closest to base first):")
    for i, r in enumerate(sorted_naive, 1):
        print(f"  {i}. {r['name']:20} ({r['naive_dist']:.4f})")

    # Are they different?
    interference_order = [r['name'] for r in sorted_interference]
    naive_order = [r['name'] for r in sorted_naive]

    if interference_order != naive_order:
        print("\nDIFFERENT RANKINGS DETECTED!")
        print("Interference method sees structural similarity differently.")
        print("\nThis could be useful if interference ranking makes more semantic sense.")
    else:
        print("\nSAME RANKINGS - Interference method doesn't add value")

    # Speed comparison
    avg_interference_time = np.mean([r['interference_time'] for r in results])
    avg_naive_time = np.mean([r['naive_time'] for r in results])

    print(f"\nSpeed:")
    print(f"  Avg Interference time: {avg_interference_time*1000:.2f}ms")
    print(f"  Avg Naive time:        {avg_naive_time*1000:.2f}ms")
    print(f"  Slowdown factor:       {avg_interference_time/avg_naive_time:.1f}x")


def test_clustering():
    """
    Can we cluster similar structures using interference signatures?
    """
    codec = InterferenceCodec()

    structures = [
        # Group 1: User profiles
        {"name": "Alice", "age": 30},
        {"name": "Bob", "age": 25},
        {"name": "Charlie", "age": 35},

        # Group 2: Products
        {"product": "Book", "price": 15.99},
        {"product": "Pen", "price": 2.50},
        {"product": "Notebook", "price": 5.00},

        # Group 3: Nested configs
        {"server": {"host": "localhost", "port": 8080}},
        {"server": {"host": "example.com", "port": 443}},

        # Group 4: Arrays
        {"data": [1, 2, 3, 4]},
        {"data": [5, 6, 7, 8]},
    ]

    print("\n" + "=" * 60)
    print("CLUSTERING TEST")
    print("=" * 60)
    print("\nCan interference signatures cluster structurally similar items?")

    # Compute all pairwise distances
    n = len(structures)
    distance_matrix = np.zeros((n, n))

    for i in range(n):
        for j in range(i+1, n):
            dist = compute_structural_distance(structures[i], structures[j], codec)
            distance_matrix[i][j] = dist
            distance_matrix[j][i] = dist

    # Simple clustering: for each item, find its nearest neighbor
    print("\nNearest neighbors:")
    for i, struct in enumerate(structures):
        distances = distance_matrix[i]
        # Exclude self
        distances_copy = distances.copy()
        distances_copy[i] = np.inf
        nearest_idx = np.argmin(distances_copy)
        nearest_dist = distances_copy[nearest_idx]

        print(f"{i}: {str(struct)[:40]:40} -> {nearest_idx} (dist={nearest_dist:.4f})")

    print("\nExpected clusters:")
    print("  Group 1 (User profiles): 0, 1, 2")
    print("  Group 2 (Products):      3, 4, 5")
    print("  Group 3 (Nested):        6, 7")
    print("  Group 4 (Arrays):        8, 9")

    print("\nDoes interference clustering match expected groups?")
    print("(Check if nearest neighbors are within expected groups)")


if __name__ == "__main__":
    test_fuzzy_matching()
    test_clustering()

    print("\n" + "=" * 60)
    print("ULTIMATE NOVELTY TEST")
    print("=" * 60)
    print("""
This is genuinely novel if:
- Clustering works better than naive string comparison
- Rankings reveal semantically meaningful similarity
- There's a use case where the dampening property is valuable

Otherwise: It's just an overcomplicated hash function.
""")
